% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/algorithm.R
\name{SIBMA}
\alias{SIBMA}
\title{SIBMA}
\usage{
SIBMA(
  factor_level,
  unit,
  particle_number = 10,
  particle_increase = 10,
  SIB_time = 3,
  all_two_level,
  P_w,
  q_GB = 1,
  q_LB = 1,
  q_new = 1,
  t = 10,
  total_unit,
  multiply_len,
  t_increase = 10,
  structure_matrix,
  treatment_effect
)
}
\arguments{
\item{factor_level}{a list. Each element is a numeric vector specifying
levels of a factor.}

\item{unit}{an integer describing the number of experimental units to be
used in a particle.}

\item{particle_number}{an integer indicating the initial particle number. Default is 10.}

\item{particle_increase}{an integer indicating how many particle number
you would like to increase in a sequential way. Default is 10.}

\item{SIB_time}{an integer indicating the number of SIB processes you would
like to run. Default is 3.}

\item{all_two_level}{logical. If all factors are two levels,
\code{all_two_level} should be \code{TRUE}; otherwise it should be
\code{FALSE}.}

\item{P_w}{a nested list. The largest list is composed of smaller lists in which
each element is a matrix describing the orthogonal projection matrix onto
the corresponding stratum variance.}

\item{q_GB}{an integer describing how many columns of a particle
should be mixed with the corresponding columns of \code{GB}. Default is 1.}

\item{q_LB}{an integer describing how many columns of a particle
should be mixed with the corresponding columns of \code{LB}. Default is 1.}

\item{q_new}{an integer describing how many columns of a particle
should be mixed with the corresponding columns of a random
particle created by \code{sibma::create_particle()}. Default is 1.}

\item{t}{an integer indicating the initial iteration number. Default is 10.}

\item{total_unit}{an integer representing the number of total run size in
a full factorial design.}

\item{multiply_len}{a numeric vector. Each element is used to modify
the value of each column in a model matrix.}

\item{t_increase}{an integer indicating the increased iteration number
you would like to increase in a sequential way. Default is 10.}

\item{structure_matrix}{a list. Each element is a matrix specifying an
incidence matrix.}

\item{treatment_effect}{a list. Each element is a numeric vector specifying
which factors should have the same treatment effect in terms of a certain
incidence matrix. The order of elements in \code{treatment_effect} should be
corresponding to that in \code{structure_matrix}.}
}
\value{
A list containing three elements:
\describe{
\item{testSIB}{A list in which each element represents the result of
each \code{SIB_time}. The result of each \code{SIB_time} contains 'X', 'LB',
'GB', 'GBMA', 'U'. 'X' denotes all the particles. 'LB' denotes the local best particles for
'X'. 'GB' denotes the global best particles. 'GBMA' denotes the word-length
patterns of 'GB' in each \code{P_w}. 'U' denotes the model matrices of 'GB'.}
\item{history}{'n_particle' and 'iteration' record the cumulative number of particles and
the cumulative number of iterations being used in the corresponding sequence.}
\item{MA_df}{The largest list contains the global best designs'
word-length patterns generated from each \code{SIB_time}. The second largest
list contains the global best designs' word-length patterns in each
\code{P_w}.}
}
}
\description{
Use swarm intelligence algorithm to search for optimal designs which satisfy the
corresponding minimum aberration criterion.
}
\details{
\code{SIBMA} works by constructing several SIB processes which controlled by
\code{SIB_time}. Each SIB process will create several particles, then select
the best particles that satisfy the corresponding minimum aberration criterion.
Therefore, users have to define \code{factor_level}, \code{unit}, and
\code{particle_number} to create particles. If the level of factors are not
all two-level, we have to transform those particles into their corresponding
orthogonal matrices, so users have to specify \code{all_two_level}.
The orthogonal matrices will be orthonormal, but \code{stats::model.matrix()}
which we use to construct a model matrix will not consider factors' intercept
effects, so users have to specify \code{multiply_len} to add factors' intercept
effects. Users also have to specify minimum aberration criteria which controlled by
\code{P_w}, and users can refer to \code{example} down below to see how to create
a legitimate format of \code{P_w}. Moreover, if the structure of designs has
effects, such as row and column effects, users have to define \code{structure_matrix}
and \code{treatment_effect}.
}
\examples{
library(sibma)

# For a design with 4 two-level factors, we only want 8 experimental units.
# Besides, we want the design has row-column structure, i.e. we want four experimental
# units have a kind of treatment generated from the first and third factors,
# so the other four experimental units have another setting.
# Moreover, we also want four experimental units have a kind of treatment
# generated from the second and fourth factors,
# so the other four experimental units have another setting.

F1 <- matrix(rep(1,8), ncol = 1)  # unstructured incidence matrix
P_w_1 <- F1 \%*\% (solve(t(F1) \%*\% F1)) \%*\% t(F1) # unstructured orthogonal projection matrix

F2 <- matrix(c(1,1,1,1,0,0,0,0, 0,0,0,0,1,1,1,1), ncol = 2)  # first stratum's incidence matrix
P_v_2 <- F2 \%*\% (solve(t(F2) \%*\% F2)) \%*\% t(F2)
P_w_2 <- P_v_2 - P_w_1  # first stratum's orthogonal projection matrix

F3 <- matrix(c(1,1,0,0,1,1,0,0, 0,0,1,1,0,0,1,1), ncol = 2)  # second stratum's incidence matrix
P_v_3 <- F3 \%*\% (solve(t(F3) \%*\% F3)) \%*\% t(F3)
P_w_3 <- P_v_3 - P_w_1  # first stratum's orthogonal projection matrix

P_w1 <- list(P_w_1)
P_w2 <- list(P_w_1, P_w_2)
P_w3 <- list(P_w_1, P_w_3)
P_w4 <- list(P_w_1, P_w_2, P_w_3)

P_w <- list(P_w1, P_w2, P_w3, P_w4)

SIBMA(factor_level = list(c(-1,1), c(-1,1), c(-1,1), c(-1,1)),
      unit = 8, particle_number = 10,
      particle_increase = 10,
      SIB_time = 3, all_two_level = TRUE, P_w = P_w, q_GB = 1, q_LB = 1,
      q_new = 1, t = 10, total_unit = 16, multiply_len = rep(1/sqrt(2)^4, 16),
      t_increase = 10, structure_matrix = list(F2, F3),
      treatment_effect = list(c(1,3), c(2,4)))

}
